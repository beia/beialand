#!/usr/bin/env python
from __future__ import print_function, division
from flask import Flask
try:
    from spidev import SpiDev
except ImportError:
    print("You don't have Spi installed")
    SpiDev = None
from abc import ABCMeta, abstractmethod


class SpiIOBase(object):
    def __init__(self, spi_id, chip_select, channel=0):
        pass

    @property
    def BIT_RESOLUTION(self):
        """ Max value that can be generated by this DAC/ADC
        """
        return 12

    @property
    def MAX_VALUE(self):
        """ Max value that can be generated by this DAC/ADC
        """
        return 2**self.BIT_RESOLUTION - 1

    @property
    def V_REF(self):
        """ Max voltage that can be generated by this DAC/ADC
        """
        return 5

    @property
    def SPI_MAX_FREQ(self):
        return 4000000 # 4 Mhz

    def get(self):
        return 0

    def set(self, level):
        pass


class SpiIOReal(SpiIOBase):
    def __init__(self, spi_id, chip_select, channel=0):
        self.spi = SpiDev()
        self.spi.open(spi_id, chip_select)
        self.max_speed_hz = self.SPI_MAX_FREQ
        self.channel = channel

    def get(self):
        adc_value = self.spi.xfer2([0b0110 | (self.channel & 0b0100) >> 2, (self.channel & 0b0011) << 6, 0])
        return ((adc_value[1] & 0b1111) << 8) + adc_value[2]

    def set(self, value):
        # 0b00000000xxxxxxxx
        # select bits from 7 to 0
        low_byte = value & 0b1111111
        # 0bxx11xxxx00000000
        # select bits from 15 to 8, set bits 12 and 13 to 1
        high_byte = ((value >> 8) & 0b1111111) | (0b0011 << 4)
        self.spi.xfer2([high_byte, low_byte])


class StatsD:
    def __init__(self, host, port=8125, prefix=None):
        from statsd import StatsClient
        self.client = StatsClient(host, port)

    def send(self, value):
        import socket
        key = prefix + "." + socket.gethostname() + "." + "peak"
        self.client.gauge(key, value)


class EmbeddedApp:
    __metaclass__ = ABCMeta

    def __init__(self):
        self.cycles = 3
        self.load_config()
        self._is_stopping = False

    @abstractmethod
    def on_init(self):
        pass

    @abstractmethod
    def on_loop(self):
        pass

    @abstractmethod
    def on_begin_measurement(self):
        pass

    @abstractmethod
    def on_begin_cycle(self, cycle_id):
        pass

    @abstractmethod
    def on_begin_step(self, step_id):
        pass

    @abstractmethod
    def store_value(self, value):
        pass

    @abstractmethod
    def load_config(self):
        pass

    def stop(self):
        self._is_stopping = True

    def sleep(self, time, what):
        from time import sleep
        if time < 0:
            raise ValueError("You didn't time your %s well. You are lacking %f seconds." % (what, -time))
        if time < self.config["sleep_interactivity"]:
            return sleep(time)
        sleep_slice = self.config["sleep_interactivity"]
        time_delta = time - int(time/sleep_slice) * sleep_slice
        for _ in range(int(time/sleep_slice)):
            if self._is_stopping:
                return
            sleep(sleep_slice)
        if self._is_stopping:
                return
        if time_delta > 0:
            sleep(time_delta)

    def main(self):
        from time import time
        self.on_init()
        while True:
            mt = time()
            self.on_begin_measurement()
            for cycle_id in range(self.config["cycles"]):
                ct = time()
                self.on_begin_cycle(cycle_id)
                for current_step in range(self.config["steps"] + 1): # hacky, but we need to go back to 0
                    st = time()
                    self.on_begin_step(current_step)
                    value = self.on_loop()
                    self.store_value(value)
                    self.sleep(self.STEP_PERIOD - (time() - st), "steps")
                    if self._is_stopping:
                        return
                self.on_after_cycle()
                self.sleep(self.CYCLE_PERIOD - (time() - ct), "cycles")
                if self._is_stopping:
                    return
            self.on_after_measurement()
            self.sleep(self.MEASUREMENT_PERIOD - (time() - mt), "measurements")
            if self._is_stopping:
                return


class CarbaApp(EmbeddedApp):

    # Constants
    @property
    def INTEGRATION_INTERVAL(self):
        return 1.0 / self.config["grid_frequency"]

    @property
    def STEP_PERIOD(self):
        return self.config["sawtooth_period"]/self.config["steps"]

    @property
    def CYCLE_PERIOD(self):
        return self.config["cycle_period"]

    @property
    def MEASUREMENT_PERIOD(self):
        return self.config["measurement_period"]


    # Utility functions
    def step_to_voltage(self, step):
        """ Calculate voltage from step number
        """
        # Here step is between 0 and max_steps/2
        min_v = self.config["min_voltage"]
        max_v = self.config["max_voltage"]
        max_steps = self.config["steps"] / 2
        if step > max_steps:
            step = self.config["steps"] - step
        return min_v + step / max_steps * (max_v - min_v)

    def voltage_to_level(self, voltage):
        level = voltage * self.output.MAX_VALUE / self.output.V_REF
        return int(round(level))

    def level_to_voltage(self, level):
        return level * self.input.V_REF / self.input.MAX_VALUE

    # Framework method implementations
    def load_config(self):
        # TODO: load from config file / cmdline arguments
        self.config = {
            # SPI
            "output_channel": 0,
            "spi_class": SpiIOBase if SpiDev is None else SpiIOReal,

            # loops - cycles
            "cycles": 3,
            # sawtooth
            "sawtooth_period": 26.0,
            ## loops - steps
            "steps": 200,

            # grid frequency - for integration
            "grid_frequency": 50,

            # output voltage
            "min_voltage": 0.0,
            "max_voltage": 1.3,

            "cycle_period": 30,
            "measurement_period": 3600,

            # statsd config
            "statsd_host": "docker-master.beia-consult.ro",
            "statsd_port": 8125,

            # interrupt
            "sleep_interactivity": 0.02,
        }

    def on_init(self):
        SpiIO = self.config["spi_class"]
        self.input = SpiIO(0, 0, self.config["output_channel"])
        self.output = SpiIO(0, 1)
        self.statsd = StatsD(self.config["statsd_host"], self.config["statsd_port"])

    def store_value(self, level):
        self.sawtooth.append(self.voltage)
        self.read_values.append(self.level_to_voltage(level))

    def on_begin_measurement(self):
        self.peaks = []
        self.series = []

    def on_begin_cycle(self, cycle_id):
        self.sawtooth = []
        self.read_values = []

    def on_begin_step(self, step):
        self.step = step
        self.voltage = self.step_to_voltage(step)
        self.output_level = self.voltage_to_level(self.voltage)

    def on_after_cycle(self):
        # TODO: replace with actual calculation - determine peak
        value = self.read_values[int(len(self.read_values)*2/3)]
        self.peaks.append(value)
        self.series.append({
                "sawtooth": self.sawtooth,
                "read_values": self.read_values,
        })

    def on_after_measurement(self):
        # send peak to Statsd?!?
        peak = sum(self.peaks) / len(self.peaks)
        self.statsd.send(peak)
        self.current_series = self.series

    def on_loop(self):
        """
        Main loop function. It sets the output level on the DAC and
        the read the input from the ADC. It will return the median the inputs
        over a 1/50 Hz interval to account for powerline frequency.
        Returns: the median of all the ADC values.
        """
        from time import time
        t = time()
        values = []
        while time() - t < self.INTEGRATION_INTERVAL:
            self.output.set(self.output_level)
            values.append(self.input.get())
        values.sort()
        return values[round(len(values)/2)]

def create_app():
    import json
    import atexit
    from threading import Thread

    app = Flask(__name__)
    carba_app = CarbaApp()
    carba_thread = Thread(target=carba_app.main)

    def interrupt():
        carba_app.stop()

    atexit.register(interrupt)

    @app.route("/")
    def homepage():
        return json.dumps(carba.current_series)

    carba_thread.start()
    return app

app = create_app()
